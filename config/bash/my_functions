#!/bin/bash

# {{{ A check for the existence of a directory.

dirExists() {
  [[ -d "$1" ]]
}

# -------------------------------------------------------------------------- }}}
# {{{ A check for the existence of a file.

fileExists() {
  [[ -f "$1" ]]
}

# -------------------------------------------------------------------------- }}}
# {{{ A check for the host name.

hostName() {
 [[ ${HOSTNAME} =~ "$1" ]]
}

# -------------------------------------------------------------------------- }}}
# {{{ A check for the existence of a program on my path.

programExists() {
  which "$1" &> /dev/null ;
}

# -------------------------------------------------------------------------- }}}
# {{{ A check for the operating system type.

osType() {
 [[ ${OSTYPE} =~ "$1" ]]
}

# -------------------------------------------------------------------------- }}}
# {{{ Append to PATH

appendToPath() {
  if dirExists "$1"; then
    [[ ":$PATH:" != *"$1"* ]] && export PATH="${PATH}:$1"
  fi
}

# -------------------------------------------------------------------------- }}}
# {{{ Prepend to PATH

prependToPath() {
  if dirExists "$1"; then
    [[ ":$PATH:" != *"$1"* ]] && export PATH="$1:${PATH}"
  fi
}

# -------------------------------------------------------------------------- }}}
# {{{ Append to INFOPATH

appendToInfoPath() {
  if dirExists "$1"; then
    [[ ":$INFOPATH:" != *"$1"* ]] && export INFOPATH="${INFOPATH}:$1"
  fi
}

# -------------------------------------------------------------------------- }}}
# {{{ Append to MANPATH

appendToManPath() {
  if dirExists "$1"; then
    [[ ":$MANPATH:" != *"$1"* ]] && export MANPATH="${MANPATH}:$1"
  fi
}

# -------------------------------------------------------------------------- }}}
# {{{ Disable features / programs running on OSX.

# if osType "darwin"; then
#   msa() { Launchctl remove com.microsoft.SyncServicesAgent ; }
#   pah() { defaults write -g ApplePressAndHoldEnable -bool false ; }
# fi

# -------------------------------------------------------------------------- }}}
# {{{ Set terminal title.

title() { echo -n -e "\033]0;$1\007"; }

# -------------------------------------------------------------------------- }}}
# {{{ Generating a new SSH key and adding it to the ssh-agent
#     https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent

sshkeys() {
  if [[ -d $SSHHOME ]]; then
    eval "$(ssh-agent -s)"
    for key in $(ls $SSHHOME/*.pub); do
      ssh-add -q "${key%.*}"
    done;
  fi
}

sshlist() {
  ps aux | awk '/ssh-agent -s/'
}

sshme() {
  echo "My ssh-agent PID ${SSH_AGENT_PID}"
}

sshkill() {
  killall ssh-agent
}

latexmkkill() {
  if osType "msys"; then
    for pid in $(ps aux | awk '/latexmk/ {print $1}'); do kill -9 $pid; done
    for pid in $(ps aux | awk '/perl/    {print $1}'); do kill -9 $pid; done
  else
    for pid in $(ps aux | awk '/latexmk/ {print $2}'); do kill -9 $pid; done
    for pid in $(ps aux | awk '/perl/    {print $2}'); do kill -9 $pid; done
  fi
}

sshstart() {
  if programExists /etc/init.d/ssh; then
    sudo /etc/init.d/ssh start
  fi
}

sshstop() {
  if programExists /etc/init.d/ssh; then
    sudo /etc/init.d/ssh stop
  fi
}

# -------------------------------------------------------------------------- }}}
# {{{ Make okular shut up on Windows.

# okular() {
#   /c/ProgramData/chocolatey/bin/okular.exe $1 > /dev/null 2>&1
# }

# -------------------------------------------------------------------------- }}}
# {{{ Cxx helper to simplify CxxTest use for C++ software.

# cxx() {
#   ${GITHOME}/cxxtest/bin/cxxtestgen --error-printer -o Test$1.cpp Test$1.h
#   g++ -w -o Test$1 Test$1.cpp
#   ./Test$1
#   rm Test$1.cpp
# }

# -------------------------------------------------------------------------- }}}
# {{{ Start Vim with client server when it is compiled in.

# if [[ ${OSTYPE} =~ "darwin" ]]; then
#   if [[ -n $(vim --version | grep clientserver) ]]; then
#     alias vimx='$EDITOR --servername VIM'
#   fi
# fi

# -------------------------------------------------------------------------- }}}
# {{{ Perforce defaults.

# if [[ ${OSTYPE} =~ "linux" ]]; then
#   if [[ ${HOSTNAME} =~ "Ryder" ]]; then
#     export P4DISK=/Volumes/Larry
#     export P4HOST=localhost
#     export P4PORT=1666
#     export P4ROOT=${P4DISK}/p4root
#     export P4CLIENT=Gary:on:Ryder
#   fi
# fi

# -------------------------------------------------------------------------- }}}
# {{{ sdkman

# if [[ -f ${HOME}/.sdkman/bin/sdkman-init.sh ]]; then
#   export SDKMAN_DIR="${HOME}/.sdkman"
#   source "${HOME}/.sdkman/bin/sdkman-init.sh"
# fi

# -------------------------------------------------------------------------- }}}
# {{{ Build gem

# bldgem() {
#   clear && cd $1 \
#      && bundle install \
#      && bundle exec rake \
#      && bundle exec rake install
# }

# -------------------------------------------------------------------------- }}}
# {{{ Build something I know about.

# bld() {
#   case $1 in
#     amber)
#       bldgem ${AMBERPATH}
#       ;;
#     emend)
#       bldgem ${GITHOME}/emend
#       ;;
#     daryn)
#       bldgem ${GITHOME}/daryn
#       ;;
#     ametrine)
#       bldgem ${GITHOME}/ametrine
#       ;;
#     *)
#       echo "bld: $1 not supported."
#       echo "Usage: bld [amber | daryn | emend| ametrine ]"
#   esac
# }

# -------------------------------------------------------------------------- }}}
# {{{ amber function.

# check-test-output() {
#   echo grep -rw --include=\*step*-status.* test-output/ -e $1
#   grep -rw --include=\*step*-status.* test-output/ -e $1
# }

# passes() {
#   check-test-output PASS
# }

# fail() {
#   check-test-output FAIL
# }

# passfail() {
#   check-test-output "PASS -e FAIL"
# }

# requirements() {
#   echo "grep -rw --include=\*.yaml factory/ -e 'requirement:'"
#   grep -rw --include=\*.yaml factory/ -e 'requirement:'
# }

# validate-git-client() {
#   cd ${GITHOME}/tool-validation/git-client
#   rm -rf _build/ test-ouput/
#   amber --nodryrun --environment --verbose --plan=command-line
#   docbld
# }
#
# validate-git-gui() {
#   cd ${GITHOME}/tool-validation/git-client
#   rm -rf _build/ test-ouput/
#   amber --nodryrun --environment --verbose --plan=command-line \
#         --language=en --browser=Chrome
#   docbld
# }

# -------------------------------------------------------------------------- }}}
# {{{ GIT_HOME is needed for test automation framework.

# if [[ -d ${HOME}/bb ]]; then
#   export GIT_HOME=${HOME}/bb
# fi

# -------------------------------------------------------------------------- }}}
# {{{ spath function tells me each part of my current path.

# spath() {
#   echo $PATH | sed -n 1'p' | tr ':' '\n' | while read word; do
#     echo $word
#   done
# }

# -------------------------------------------------------------------------- }}}
# {{{ main moves me to main and shows me a few commits.

br() {
  git co $1
}

main() {
  br main
  clear
  git logg -15
}

# -------------------------------------------------------------------------- }}}
# {{{ Grep my history for a prior command I used.

hg() {
  history | grep "$1"
}

# -------------------------------------------------------------------------- }}}
# {{{ cj & gh are functions that I rewrite all the time to simplify my life.

cj() {
  newdoc --dir=$1/$2 --file=$2 --title=$2 $3 $4
}

dh() {
  clear && docbld clobber && docbld texx && ll && zathura $1
}

# -------------------------------------------------------------------------- }}}
# {{{ Use LaTeX make to generate a document.

pdf() {
  latexmk -pdf -verbose -file-line-error -synctex=1 -interaction=nonstopmode -cd $1
}

# -------------------------------------------------------------------------- }}}
# {{{ Archvie extractor

# ex = EXtractor for all kinds of archives
# usage: ex <file>

ex() {
	if [ -f $1 ]; then
		case $1 in
		*.tar.bz2) tar xjf $1 ;;
		*.tar.gz) tar xzf $1 ;;
		*.bz2) bunzip2 $1 ;;
		*.rar) unrar x $1 ;;
		*.gz) gunzip $1 ;;
		*.tar) tar xf $1 ;;
		*.tbz2) tar xjf $1 ;;
		*.tgz) tar xzf $1 ;;
		*.zip) unzip $1 ;;
		*.Z) uncompress $1 ;;
		*.7z) 7z x $1 ;;
		*deb) ar x $1 ;;
		*.tar.xz) tar xf $1 ;;
		*.tar.zst) unzstd $1 ;;
		*) echo "'$1' cannot be extracted via ex()" ;;
		esac
	else
		echo "'$1' is not a valid file"
	fi
}

# -------------------------------------------------------------------------- }}}




# Functions
function color() {
    local fgc bgc vals seq0

    printf "Color escapes are %s\n" '\e[${value};...;${value}m'
    printf "Values 30..37 are \e[33mforeground colors\e[m\n"
    printf "Values 40..47 are \e[43mbackground colors\e[m\n"
    printf "Value  1 gives a  \e[1mbold-faced look\e[m\n\n"

    # foreground colors
    for fgc in {30..37}; do
        # background colors
        for bgc in {40..47}; do
            fgc=${fgc#37} # white
            bgc=${bgc#40} # black

            vals="${fgc:+$fgc;}${bgc}"
            vals=${vals%%;}

            seq0="${vals:+\e[${vals}m}"
            printf "  %-9s" "${seq0:-(default)}"
            printf " ${seq0}TEXT\e[m"
            printf " \e[${vals:+${vals+$vals;}}1mBOLD\e[m"
        done
        echo
        echo
    done
}

# cd into dir and list contents
function lc() {
    cd "$1" && la "$2"
}

# Make directory and cd into it
function mcd() {
    mkdir -p -- "$1" && cd -P -- "$1"
}

function tmux-clean() {
    tmux list-sessions | grep -E -v '\(attached\)$' | while IFS='\n' read line; do
        tmux kill-session -t "${line%%:*}"
    done
}

# Execute command in directory
function xin() {
    (cd "${1}" && shift && ${@})
}

function man() {
    env \
        LESS_TERMCAP_mb=$(printf "\e[1;31m") \
        LESS_TERMCAP_md=$(printf "\e[1;36m") \
        LESS_TERMCAP_me=$(printf "\e[0m") \
        LESS_TERMCAP_se=$(printf "\e[0m") \
        LESS_TERMCAP_so=$(printf "\e[1;44;33m") \
        LESS_TERMCAP_ue=$(printf "\e[0m") \
        LESS_TERMCAP_us=$(printf "\e[1;32m") \
        PAGER="${commands[less]:-$PAGER}" \
        _NROFF_U=1 \
        PATH="$HOME/bin:$PATH" \
        man "$@"
}

# markdown link check
function mlc() {
    find $1 -name \*.md -exec markdown-link-check -p {} \;
}

# lg() {
#     export LAZYGIT_NEW_DIR_FILE=~/.config/lazygit/.tmp
#     lazygit "$@"
#
#     if [ -f $LAZYGIT_NEW_DIR_FILE ]; then
#         cd "$(cat $LAZYGIT_NEW_DIR_FILE)"
#         rm -f $LAZYGIT_NEW_DIR_FILE >/dev/null
#     fi
# }

# Runs when tab is pressed after ,
_fzf_comprun() {
    local command=$1
    shift

    case "$command" in
    cd) fzf "$@" --preview 'exa -TFl --group-directories-first --icons --git -L 2 --no-user {}' ;;
    nvim) fzf --preview 'bat --color=always --style=numbers --line-range=:500 {}' ;;
    vim) fzf --preview 'bat --color=always --style=numbers --line-range=:500 {}' ;;
    *) fzf "$@" ;;
    esac
}

# Only show files which have $1 present in contents
faz() {
    local line
    line=$(rg "$1" | fzf) &&
        $EDITOR $(cut -d':' -f1 <<<"$line") +$(cut -d':' -f2 <<<"$line")
}

fz() {
    local line
    line=$(rg "$1" | fzf) &&
        $EDITOR $(cut -d':' -f1 <<<"$line") +$(cut -d':' -f2 <<<"$line")
}

todos() {
    cd "$NOTES_ROOT" || return
    $EDITOR "$(rg -le '- \[ \]' --sort created | fzf)"
    cd - || return
}

accent() {
    color="#1688f0"

    if [[ $1 == '#'* ]]; then
        color=$1
    elif [ -z "$1" ]; then
        color="#1688f0"
    else
        color="#$1"
    fi

    sed -i "s/local accent.*/local accent = '$color'/" ~/.config/awesome/awesome2k.lua
    sed -i "s/selected.*/selected:       $color;/" ~/.config/rofi/themes/shared/colors.rasi
    echo 'awesome.restart()' | awesome-client
}
